<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multiplayer Ball Game</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }
        
        .game-container {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
            border: 1px solid rgba(255, 255, 255, 0.18);
        }
        
        #gameCanvas {
            border: 2px solid #fff;
            border-radius: 10px;
            background: rgba(0, 0, 0, 0.8);
            display: block;
            cursor: crosshair;
        }
        
        .info {
            color: white;
            text-align: center;
            margin: 15px 0;
            font-size: 14px;
        }
        
        .controls {
            color: white;
            text-align: center;
            margin-top: 10px;
            font-size: 12px;
            opacity: 0.8;
        }
        
        .player-info {
            color: white;
            text-align: center;
            margin: 10px 0;
            font-weight: bold;
        }
        
        .zoom-info {
            color: white;
            text-align: center;
            margin: 5px 0;
            font-size: 12px;
            opacity: 0.9;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="info">
            <h2 style="margin: 0 0 10px 0; color: white;">ðŸŽ® Ball Teleporter Arena</h2>
        </div>
        
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        
        <div class="player-info">
            <div id="playerStatus">Click anywhere to place/teleport your ball!</div>
            <div>Players Online: <span id="playerCount">0</span></div>
        </div>
        
        <div class="zoom-info">
            Zoom: <span id="zoomLevel">1.0x</span> | World Size: <span id="worldSize">800x600</span>
        </div>
        
        <div class="controls">
            WASD/Arrow Keys: Move â€¢ Click: Teleport Ball â€¢ Mouse Wheel/+/-: Zoom<br>
            Balls bounce off world boundaries and each other
        </div>
    </div>

    <script>
        class BallGame {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.players = new Map();
                this.playerId = 'player';
                this.keys = {};
                this.myPlayer = null;
                
                // Camera and zoom properties
                this.camera = { x: 0, y: 0 };
                this.zoom = 1.0;
                this.minZoom = 0.2;
                this.maxZoom = 3.0;
                this.worldWidth = 800;
                this.worldHeight = 600;
                
                this.speed = 4;
                this.ballRadius = 20;
                this.friction = 0.98;
                this.bounceDamping = 0.8;
                
                this.colors = ['#ff4757', '#2ed573', '#3742fa', '#ffa502', '#ff6b81', '#70a1ff'];
                
                this.setupControls();
                this.addBots();
                this.updateZoomDisplay();
                this.gameLoop();
            }
            
            setupControls() {
                const gameKeys = ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'w', 'a', 's', 'd'];
                
                document.addEventListener('keydown', (e) => {
                    const key = e.key.toLowerCase();
                    if (gameKeys.includes(e.key) || gameKeys.includes(key)) {
                        e.preventDefault();
                        this.keys[key] = true;
                    }
                    
                    // Zoom controls with keyboard
                    if (e.key === '=' || e.key === '+') {
                        e.preventDefault();
                        this.adjustZoom(0.1);
                    } else if (e.key === '-' || e.key === '_') {
                        e.preventDefault();
                        this.adjustZoom(-0.1);
                    }
                });
                
                document.addEventListener('keyup', (e) => {
                    const key = e.key.toLowerCase();
                    if (gameKeys.includes(e.key) || gameKeys.includes(key)) {
                        e.preventDefault();
                        this.keys[key] = false;
                    }
                });
                
                // Mouse wheel zoom
                this.canvas.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    const zoomDelta = e.deltaY > 0 ? -0.1 : 0.1;
                    this.adjustZoom(zoomDelta);
                });
                
                // Click to spawn or teleport ball
                this.canvas.addEventListener('click', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    const canvasX = e.clientX - rect.left;
                    const canvasY = e.clientY - rect.top;
                    
                    // Convert canvas coordinates to world coordinates
                    const worldX = (canvasX / this.zoom) + this.camera.x;
                    const worldY = (canvasY / this.zoom) + this.camera.y;
                    
                    // Clamp to world boundaries
                    const clampedX = Math.max(this.ballRadius, Math.min(this.worldWidth - this.ballRadius, worldX));
                    const clampedY = Math.max(this.ballRadius, Math.min(this.worldHeight - this.ballRadius, worldY));
                    
                    if (this.myPlayer) {
                        // Teleport existing ball, keep velocity
                        this.myPlayer.x = clampedX;
                        this.myPlayer.y = clampedY;
                    } else {
                        // Create new ball
                        this.myPlayer = {
                            id: this.playerId,
                            x: clampedX,
                            y: clampedY,
                            vx: 0,
                            vy: 0,
                            color: this.colors[0]
                        };
                        this.players.set(this.playerId, this.myPlayer);
                        document.getElementById('playerStatus').innerHTML = `Your Ball: <span style="color: ${this.myPlayer.color}">${this.myPlayer.color}</span>`;
                    }
                    this.updateCount();
                });
            }
            
            adjustZoom(delta) {
                const oldZoom = this.zoom;
                this.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.zoom + delta));
                
                // Adjust world size based on zoom (zooming in = smaller effective world)
                this.worldWidth = 800 / this.zoom;
                this.worldHeight = 600 / this.zoom;
                
                // Keep camera centered when zoom changes
                if (this.myPlayer) {
                    this.camera.x = this.myPlayer.x - (this.canvas.width / this.zoom) / 2;
                    this.camera.y = this.myPlayer.y - (this.canvas.height / this.zoom) / 2;
                }
                
                // Clamp camera to world bounds
                this.clampCamera();
                this.updateZoomDisplay();
            }
            
            clampCamera() {
                const viewWidth = this.canvas.width / this.zoom;
                const viewHeight = this.canvas.height / this.zoom;
                
                this.camera.x = Math.max(0, Math.min(this.worldWidth - viewWidth, this.camera.x));
                this.camera.y = Math.max(0, Math.min(this.worldHeight - viewHeight, this.camera.y));
            }
            
            updateZoomDisplay() {
                document.getElementById('zoomLevel').textContent = this.zoom.toFixed(1) + 'x';
                document.getElementById('worldSize').textContent = `${Math.round(this.worldWidth)}x${Math.round(this.worldHeight)}`;
            }
            
            addBots() {
                // Add 3 bot players
                for (let i = 1; i <= 3; i++) {
                    const bot = {
                        id: `bot${i}`,
                        x: Math.random() * (this.worldWidth - 40) + 20,
                        y: Math.random() * (this.worldHeight - 40) + 20,
                        vx: (Math.random() - 0.5) * 4,
                        vy: (Math.random() - 0.5) * 4,
                        color: this.colors[i],
                        isBot: true
                    };
                    this.players.set(bot.id, bot);
                }
                this.updateCount();
            }
            
            updateCount() {
                document.getElementById('playerCount').textContent = this.players.size;
            }
            
            updatePlayer() {
                if (!this.myPlayer) return;
                
                let dx = 0, dy = 0;
                
                if (this.keys['w'] || this.keys['arrowup']) dy -= this.speed;
                if (this.keys['s'] || this.keys['arrowdown']) dy += this.speed;
                if (this.keys['a'] || this.keys['arrowleft']) dx -= this.speed;
                if (this.keys['d'] || this.keys['arrowright']) dx += this.speed;
                
                if (dx !== 0 && dy !== 0) {
                    dx *= 0.707;
                    dy *= 0.707;
                }
                
                this.myPlayer.vx += dx * 0.3;
                this.myPlayer.vy += dy * 0.3;
                this.myPlayer.vx *= this.friction;
                this.myPlayer.vy *= this.friction;
                
                this.myPlayer.x += this.myPlayer.vx;
                this.myPlayer.y += this.myPlayer.vy;
                
                this.handleWallBounce(this.myPlayer);
                
                // Update camera to follow player
                this.camera.x = this.myPlayer.x - (this.canvas.width / this.zoom) / 2;
                this.camera.y = this.myPlayer.y - (this.canvas.height / this.zoom) / 2;
                this.clampCamera();
            }
            
            updateBots() {
                this.players.forEach(player => {
                    if (player.isBot) {
                        player.x += player.vx;
                        player.y += player.vy;
                        player.vx *= this.friction;
                        player.vy *= this.friction;
                        
                        if (Math.random() < 0.005) {
                            player.vx += (Math.random() - 0.5) * 3;
                            player.vy += (Math.random() - 0.5) * 3;
                        }
                        
                        this.handleWallBounce(player);
                    }
                });
            }
            
            handleWallBounce(player) {
                if (player.x - this.ballRadius <= 0 || player.x + this.ballRadius >= this.worldWidth) {
                    player.vx *= -this.bounceDamping;
                    player.x = Math.max(this.ballRadius, Math.min(this.worldWidth - this.ballRadius, player.x));
                }
                
                if (player.y - this.ballRadius <= 0 || player.y + this.ballRadius >= this.worldHeight) {
                    player.vy *= -this.bounceDamping;
                    player.y = Math.max(this.ballRadius, Math.min(this.worldHeight - this.ballRadius, player.y));
                }
            }
            
            handleCollisions() {
                const balls = Array.from(this.players.values());
                
                for (let i = 0; i < balls.length; i++) {
                    for (let j = i + 1; j < balls.length; j++) {
                        const ball1 = balls[i];
                        const ball2 = balls[j];
                        
                        const dx = ball2.x - ball1.x;
                        const dy = ball2.y - ball1.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < this.ballRadius * 2) {
                            // Separate balls
                            const overlap = this.ballRadius * 2 - distance;
                            const moveX = (overlap / 2) * (dx / distance);
                            const moveY = (overlap / 2) * (dy / distance);
                            
                            ball1.x -= moveX;
                            ball1.y -= moveY;
                            ball2.x += moveX;
                            ball2.y += moveY;
                            
                            // Bounce
                            const tempVx = ball1.vx;
                            const tempVy = ball1.vy;
                            ball1.vx = ball2.vx * this.bounceDamping;
                            ball1.vy = ball2.vy * this.bounceDamping;
                            ball2.vx = tempVx * this.bounceDamping;
                            ball2.vy = tempVy * this.bounceDamping;
                        }
                    }
                }
            }
            
            // Convert world coordinates to screen coordinates
            worldToScreen(worldX, worldY) {
                return {
                    x: (worldX - this.camera.x) * this.zoom,
                    y: (worldY - this.camera.y) * this.zoom
                };
            }
            
            render() {
                // Clear canvas
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.95)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw world boundaries
                const topLeft = this.worldToScreen(0, 0);
                const bottomRight = this.worldToScreen(this.worldWidth, this.worldHeight);
                
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                this.ctx.lineWidth = 2;
                this.ctx.strokeRect(topLeft.x, topLeft.y, bottomRight.x - topLeft.x, bottomRight.y - topLeft.y);
                
                // Draw grid for reference when zoomed
                if (this.zoom > 1) {
                    this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                    this.ctx.lineWidth = 1;
                    
                    const gridSize = 50;
                    const startX = Math.floor(this.camera.x / gridSize) * gridSize;
                    const startY = Math.floor(this.camera.y / gridSize) * gridSize;
                    const endX = this.camera.x + (this.canvas.width / this.zoom);
                    const endY = this.camera.y + (this.canvas.height / this.zoom);
                    
                    for (let x = startX; x <= endX; x += gridSize) {
                        const screenPos = this.worldToScreen(x, this.camera.y);
                        this.ctx.beginPath();
                        this.ctx.moveTo(screenPos.x, 0);
                        this.ctx.lineTo(screenPos.x, this.canvas.height);
                        this.ctx.stroke();
                    }
                    
                    for (let y = startY; y <= endY; y += gridSize) {
                        const screenPos = this.worldToScreen(this.camera.x, y);
                        this.ctx.beginPath();
                        this.ctx.moveTo(0, screenPos.y);
                        this.ctx.lineTo(this.canvas.width, screenPos.y);
                        this.ctx.stroke();
                    }
                }
                
                // Draw players
                this.players.forEach(player => {
                    const screenPos = this.worldToScreen(player.x, player.y);
                    const screenRadius = this.ballRadius * this.zoom;
                    
                    // Only draw if visible on screen
                    if (screenPos.x + screenRadius >= 0 && screenPos.x - screenRadius <= this.canvas.width &&
                        screenPos.y + screenRadius >= 0 && screenPos.y - screenRadius <= this.canvas.height) {
                        
                        // Velocity trail
                        if (Math.abs(player.vx) > 0.5 || Math.abs(player.vy) > 0.5) {
                            const trailEnd = this.worldToScreen(player.x - player.vx * 3, player.y - player.vy * 3);
                            this.ctx.strokeStyle = player.color + '40';
                            this.ctx.lineWidth = 3 * this.zoom;
                            this.ctx.beginPath();
                            this.ctx.moveTo(screenPos.x, screenPos.y);
                            this.ctx.lineTo(trailEnd.x, trailEnd.y);
                            this.ctx.stroke();
                        }
                        
                        // Glow for player's ball
                        if (player.id === this.playerId) {
                            this.ctx.shadowColor = player.color;
                            this.ctx.shadowBlur = 25 * this.zoom;
                        }
                        
                        // Ball
                        this.ctx.beginPath();
                        this.ctx.arc(screenPos.x, screenPos.y, screenRadius, 0, Math.PI * 2);
                        this.ctx.fillStyle = player.color;
                        this.ctx.fill();
                        
                        // Highlight
                        this.ctx.beginPath();
                        this.ctx.arc(screenPos.x - 5 * this.zoom, screenPos.y - 5 * this.zoom, screenRadius * 0.3, 0, Math.PI * 2);
                        this.ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                        this.ctx.fill();
                        
                        // Player border
                        if (player.id === this.playerId) {
                            this.ctx.strokeStyle = '#ffffff';
                            this.ctx.lineWidth = 3 * this.zoom;
                            this.ctx.beginPath();
                            this.ctx.arc(screenPos.x, screenPos.y, screenRadius + 3 * this.zoom, 0, Math.PI * 2);
                            this.ctx.stroke();
                        }
                        
                        this.ctx.shadowBlur = 0;
                    }
                });
            }
            
            gameLoop() {
                this.updatePlayer();
                this.updateBots();
                this.handleCollisions();
                this.render();
                requestAnimationFrame(() => this.gameLoop());
            }
        }
        
        window.addEventListener('load', () => {
            new BallGame();
        });
    </script>
</body>
</html>